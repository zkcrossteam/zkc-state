syntax = "proto3";

package datastore;

// The state root, a compact representation (usually a hash) of all the data in
// current data store. Different contents in the data store are computationally
// guaranteed to have different state roots. Applications may view this as the
// version number of their data.
message DataRoot { bytes value = 1; }

// An opaque data structure used to indicate which slot in the data store is
// this data stored. Applications may view this as the key to the data they want
// to store.
message DataCookie { bytes value = 1; }

// Any data applications want to store in the data store.
message DataContent { bytes value = 1; }

message Data {
  DataCookie cookie = 2;
  DataContent content = 3;
}

message DataResponse {
  DataRoot root = 1;
  Data data = 2;
}

message BatchDataResponse {
  DataRoot root = 1;
  repeated Data data = 2;
}

message RetrievingDataRequest {
  optional DataRoot root = 1;
  DataCookie cookie = 2;
}

message BatchRetrievingDataRequest {
  optional DataRoot root = 1;
  repeated DataCookie cookies = 2;
}

message SavingDataRequest {
  optional DataRoot root = 1;
  DataContent content = 2;
}

message BatchSavingDataRequest {
  optional DataRoot root = 1;
  repeated DataContent contents = 2;
}

message GettingCookiesRequest { optional DataRoot root = 1; }

message CookiesResponse {
  DataRoot root = 1;
  repeated DataCookie cookies = 2;
}

service DataStore {
  // Retrieving the data with supplied cookie from data store. When optional
  // root is supplied, only the data with that root will be returned. This is
  // useful to obtain some specific version of the data.
  rpc RetrieveData(RetrievingDataRequest) returns (DataResponse) {}

  // The batch version of `RetrieveData`.
  rpc BatchRetrieveData(RetrievingDataRequest) returns (BatchDataResponse) {}

  // Saving content to the data store. When the optional root is supplied, the
  // data store will check if the current root is the supplied root, if it is
  // not the case the data will not be saved. This is useful when the client
  // want to ensure some kind of data consistency.
  rpc SaveData(SavingDataRequest) returns (DataResponse) {}

  // The batch version of `BatchSaveData`.
  rpc BatchSaveData(SavingDataRequest) returns (BatchDataResponse) {}

  // Getting all the cookies of the data store. If root is supplied, then only
  // the data in that root will be returned. Otherwise, only data with current
  // root will be returned.
  rpc GetAllCookies(GettingCookiesRequest) returns (CookiesResponse) {}
}

message Key {
  string key = 1;
  // An optional owner public key, used to authorize key value update.
  // Current unused.
  optional bytes owner = 2;
}
message Value { bytes value = 1; }

message KVPair {
  Key key = 1;
  Value value = 2;
};

enum ProofType {
  ProofUnspecified = 0; // Default enum value, should not be used
  ProofEmpty = 1;       // No proof
  ProofV0 = 2;
}

// A proof to validate whether some key value pair exists in the KVStore.
message Proof {
  ProofType proof_type = 1;
  bytes proof = 2;
}

message KVGetRequest {
  Key key = 1;
  ProofType proof_type = 2;
}

message KVGetResponse {
  DataRoot root = 1;
  KVPair kv = 2;
  Proof proof = 3;
}

enum SignatureType {
  SignatureUnspecified = 0; // Default enum value, should not be used
  SignatureEmpty = 1;       // No proofs
  SignatureV0 = 2;
}

// A signature signed by the owner of some key to authorize the key value pair
// update.
message Signature {
  SignatureType proof_type = 1;
  bytes signature = 2;
}

message KVSetRequest {
  KVPair kv = 1;
  optional Signature signature = 2;
}

message KVSetResponse {
  DataRoot root = 1;
  KVPair kv = 2;
  Proof proof = 3;
};

message KVProveRequest {
  KVPair kv = 1;
  ProofType proof_type = 2;
}

message KVProveResponse { bool is_valid = 1; }

message KVGetRootRequest {}

message KVGetRootReponse { bytes root = 1; }

service KVStore {
  // Get current state root.
  rpc GetCurrentRoot(KVGetRootRequest) returns (KVGetRootReponse) {}
  rpc Get(KVGetRequest) returns (KVGetResponse) {}
  rpc Set(KVSetRequest) returns (KVSetResponse) {}
  rpc Prove(KVProveRequest) returns (KVProveResponse) {}
}
